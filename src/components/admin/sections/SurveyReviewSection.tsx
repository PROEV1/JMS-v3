import { useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { useToast } from '@/hooks/use-toast';
import { supabase } from '@/integrations/supabase/client';
import { CheckCircle, XCircle, FileText, Plus, Mail } from 'lucide-react';
import { useNavigate } from 'react-router-dom';

interface SurveyReviewSectionProps {
  order: {
    id: string;
    client_id: string;
    quote_id: string | null;
    status_enhanced: string;
  };
  survey: {
    id: string;
    status: string;
    responses: any;
    submitted_at: string;
    review_notes?: string;
    reviewed_at?: string;
  };
  onUpdate?: () => void;
}

export function SurveyReviewSection({ order, survey, onUpdate }: SurveyReviewSectionProps) {
  const [reviewNotes, setReviewNotes] = useState(survey.review_notes || '');
  const [isApproving, setIsApproving] = useState(false);
  const [isRequestingRework, setIsRequestingRework] = useState(false);
  const [isCreatingRevision, setIsCreatingRevision] = useState(false);
  const [isSendingQuote, setIsSendingQuote] = useState(false);
  const { toast } = useToast();
  const navigate = useNavigate();

  const handleApproveSurvey = async () => {
    setIsApproving(true);
    try {
      // Update survey status
      const { error: surveyError } = await supabase
        .from('client_surveys')
        .update({
          status: 'approved',
          review_notes: reviewNotes,
          reviewed_at: new Date().toISOString()
        })
        .eq('id', survey.id);

      if (surveyError) throw surveyError;

      // Update order status
      const { error: orderError } = await supabase
        .from('orders')
        .update({ status_enhanced: 'survey_approved' })
        .eq('id', order.id);

      if (orderError) throw orderError;

      toast({
        title: "Survey Approved",
        description: "Survey has been approved and order status updated",
      });

      onUpdate?.();
    } catch (error) {
      console.error('Error approving survey:', error);
      toast({
        title: "Error",
        description: "Failed to approve survey",
        variant: "destructive",
      });
    } finally {
      setIsApproving(false);
    }
  };

  const handleRequestRework = async () => {
    if (!reviewNotes.trim()) {
      toast({
        title: "Error",
        description: "Please provide review notes explaining what needs to be fixed",
        variant: "destructive",
      });
      return;
    }

    setIsRequestingRework(true);
    try {
      // Update survey status
      const { error: surveyError } = await supabase
        .from('client_surveys')
        .update({
          status: 'rework_requested',
          review_notes: reviewNotes,
          reviewed_at: new Date().toISOString()
        })
        .eq('id', survey.id);

      if (surveyError) throw surveyError;

      // Update order status
      const { error: orderError } = await supabase
        .from('orders')
        .update({ status_enhanced: 'survey_rework_requested' })
        .eq('id', order.id);

      if (orderError) throw orderError;

      // Send rework email to client
      await supabase.functions.invoke('send-survey-rework-email', {
        body: {
          orderId: order.id,
          reviewNotes: reviewNotes
        }
      });

      toast({
        title: "Rework Requested",
        description: "Client has been notified about the required changes",
      });

      onUpdate?.();
    } catch (error) {
      console.error('Error requesting rework:', error);
      toast({
        title: "Error",
        description: "Failed to request rework",
        variant: "destructive",
      });
    } finally {
      setIsRequestingRework(false);
    }
  };

  const handleCreateRevisedQuote = async () => {
    if (!order.quote_id) {
      toast({
        title: "Error",
        description: "No original quote found to revise",
        variant: "destructive",
      });
      return;
    }

    setIsCreatingRevision(true);
    try {
      // Fetch the original quote data
      const { data: originalQuote, error: fetchError } = await supabase
        .from('quotes')
        .select('*')
        .eq('id', order.quote_id)
        .single();

      if (fetchError) throw fetchError;

      // Create a new quote based on the original
      const { data: newQuote, error: createError } = await supabase
        .from('quotes')
        .insert({
          client_id: order.client_id,
          order_id: order.id,
          quote_number: '', // Will be auto-generated by trigger
          total_cost: originalQuote.total_cost,
          materials_cost: originalQuote.materials_cost,
          install_cost: originalQuote.install_cost,
          extras_cost: originalQuote.extras_cost,
          product_details: originalQuote.product_details,
          special_instructions: originalQuote.special_instructions,
          warranty_period: originalQuote.warranty_period,
          includes_installation: originalQuote.includes_installation,
          notes: `Revised quote based on survey review - ${originalQuote.quote_number}`,
          status: 'draft'
        })
        .select()
        .single();

      if (createError) throw createError;

      // Copy quote items if they exist
      const { data: originalItems } = await supabase
        .from('quote_items')
        .select('*')
        .eq('quote_id', order.quote_id);

      if (originalItems && originalItems.length > 0) {
        const newItems = originalItems.map(item => ({
          quote_id: newQuote.id,
          product_id: item.product_id,
          product_name: item.product_name,
          quantity: item.quantity,
          unit_price: item.unit_price,
          total_price: item.total_price,
          configuration: item.configuration
        }));

        await supabase
          .from('quote_items')
          .insert(newItems);
      }

      // Update order with new quote_id
      await supabase
        .from('orders')
        .update({ quote_id: newQuote.id })
        .eq('id', order.id);

      toast({
        title: "Revised Quote Created",
        description: "A new quote has been created for revision. Redirecting to edit...",
      });

      // Redirect to edit the new quote
      setTimeout(() => {
        navigate(`/admin/quotes/${newQuote.id}/edit`);
      }, 1500);

    } catch (error) {
      console.error('Error creating revised quote:', error);
      toast({
        title: "Error",
        description: "Failed to create revised quote",
        variant: "destructive",
      });
    } finally {
      setIsCreatingRevision(false);
    }
  };

  const handleSendCurrentQuote = async () => {
    if (!order.quote_id) {
      toast({
        title: "Error",
        description: "No quote found to send",
        variant: "destructive",
      });
      return;
    }

    setIsSendingQuote(true);
    try {
      // Send quote via email
      const { error } = await supabase.functions.invoke('send-revised-quote', {
        body: {
          quoteId: order.quote_id,
          revisionReason: 'Survey review completed - quote confirmed'
        }
      });

      if (error) throw error;

      toast({
        title: "Quote Sent",
        description: "Quote has been sent to client for acceptance",
      });

      onUpdate?.();
    } catch (error) {
      console.error('Error sending quote:', error);
      toast({
        title: "Error",
        description: "Failed to send quote",
        variant: "destructive",
      });
    } finally {
      setIsSendingQuote(false);
    }
  };

  const getStatusBadge = (status: string) => {
    const statusConfig = {
      submitted: { label: 'Awaiting Review', color: 'bg-yellow-100 text-yellow-800' },
      approved: { label: 'Approved', color: 'bg-green-100 text-green-800' },
      rework_requested: { label: 'Rework Requested', color: 'bg-red-100 text-red-800' },
    };
    
    const config = statusConfig[status as keyof typeof statusConfig];
    return (
      <Badge className={config?.color || 'bg-gray-100 text-gray-800'}>
        {config?.label || status}
      </Badge>
    );
  };

  const showReviewActions = survey.status === 'submitted' || survey.status === 'resubmitted';

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <FileText className="h-5 w-5" />
            Survey Review
          </div>
          {getStatusBadge(survey.status)}
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-6">
        <div className="space-y-4">
          <div>
            <span className="text-sm font-medium text-muted-foreground">Submitted:</span>
            <span className="ml-2">{new Date(survey.submitted_at).toLocaleDateString()}</span>
          </div>
          {survey.reviewed_at && (
            <div>
              <span className="text-sm font-medium text-muted-foreground">Reviewed:</span>
              <span className="ml-2">{new Date(survey.reviewed_at).toLocaleDateString()}</span>
            </div>
          )}
        </div>

        {showReviewActions && (
          <div className="space-y-4">
            <div>
              <Label htmlFor="review-notes">Review Notes</Label>
              <Textarea
                id="review-notes"
                placeholder="Add any notes about the survey review..."
                value={reviewNotes}
                onChange={(e) => setReviewNotes(e.target.value)}
                className="mt-1"
              />
            </div>

            <div className="flex gap-3">
              <Button
                onClick={handleApproveSurvey}
                disabled={isApproving}
                className="bg-green-600 hover:bg-green-700"
              >
                <CheckCircle className="h-4 w-4 mr-2" />
                {isApproving ? 'Approving...' : 'Approve Survey'}
              </Button>
              
              <Button
                onClick={handleRequestRework}
                disabled={isRequestingRework}
                variant="destructive"
              >
                <XCircle className="h-4 w-4 mr-2" />
                {isRequestingRework ? 'Requesting...' : 'Request Rework'}
              </Button>
            </div>
          </div>
        )}

        {survey.status === 'approved' && (
          <div className="space-y-4 pt-4 border-t">
            <h4 className="font-medium">Next Steps</h4>
            <div className="flex gap-3">
              <Button
                onClick={handleCreateRevisedQuote}
                disabled={isCreatingRevision}
                variant="outline"
              >
                <Plus className="h-4 w-4 mr-2" />
                {isCreatingRevision ? 'Creating...' : 'Create Revised Quote'}
              </Button>
              
              <Button
                onClick={handleSendCurrentQuote}
                disabled={isSendingQuote}
                className="bg-blue-600 hover:bg-blue-700"
              >
                <Mail className="h-4 w-4 mr-2" />
                {isSendingQuote ? 'Sending...' : 'Send Current Quote'}
              </Button>
            </div>
            <p className="text-sm text-muted-foreground">
              Create a revised quote to make changes based on the survey, or send the current quote if no changes are needed.
            </p>
          </div>
        )}

        {survey.review_notes && (
          <div className="pt-4 border-t">
            <Label>Previous Review Notes</Label>
            <div className="mt-1 p-3 bg-muted rounded-md">
              <p className="text-sm">{survey.review_notes}</p>
            </div>
          </div>
        )}
      </CardContent>
    </Card>
  );
}